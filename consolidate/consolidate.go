// This package provide two way of event consolidation:
//   - events that are function calls (use Func constructor for such a cases)
//   - events which are chan messages (use Chan constructor for such a cases)
//
// In both cases the events comes from origin source will be consolidated and passed to destination source wia following procedure:
//   - when some series of origin events are separated by long intervals without events the each such bunch of events will be translated to single output event
//   - if the sequence of origin events has no intervals without events then the output event will be generated with some frequency that much less than frequency of origin events.
package consolidate

import (
	"time"
)

type consolidate struct {
	ch         chan struct{}
	doFunc     func()
	cancel     chan struct{}
	delay      time.Duration
	maxDelay   time.Duration
	delayTimer *time.Timer
	wdTimer    <-chan time.Time
}

// Func constructor creates consolidation function that have to be called when origin event appear. The function cFunc that will to be called on consolidated event is passed to the constructor.
// delay - determines interval between last origin event into the bunch of them and generated event. When some event appears during that interval it resets the waiting again to delay.
// The events that comes very frequently the outgoing event never will be generated by this mechanism. To solve this issue another timer is set on the very first event after start or after last outgoing event.
// This timer is set by maxDelay and if the first mechanism fails the outgoing event will be generated when maxDelay expired.
func Func(delay, maxDelay time.Duration, cFunc func()) (func(), func()) {
	c := newConsolidator(delay, maxDelay, cFunc)
	return c.eventFunc, c.close
}

// Chan constructor creates consolidation chan that have to be filled by messages as origin events. The outCh that will be filled with consolidated events is passed to the constructor.
// delay - determines interval between last origin event into the bunch of them and generated event. When some event appears during that interval it resets the waiting again to delay.
// The events that comes very frequently the outgoing event never will be generated by this mechanism. To solve this issue another timer is set on the very first event after start or after last outgoing event.
// This timer is set by maxDelay and if the first mechanism fails the outgoing event will be generated when maxDelay expired.
func Chan(delay, maxDelay time.Duration, outCh chan struct{}) (chan struct{}, func()) {
	c := newConsolidator(delay, maxDelay, func() {
		select {
		case outCh <- struct{}{}:
		default:
		}
	})
	return c.ch, c.close
}

func newConsolidator(delay, maxDelay time.Duration, do func()) *consolidate {
	c := &consolidate{
		delay:      delay,
		maxDelay:   maxDelay,
		ch:         make(chan struct{}, 1),
		doFunc:     do,
		cancel:     make(chan struct{}),
		delayTimer: time.NewTimer(time.Hour),
	}
	c.delayTimer.Stop()
	go c.loop()
	return c
}

func (c *consolidate) eventFunc() {
	select {
	case c.ch <- struct{}{}:
	default:
	}
}

func (r *consolidate) close() {
	select {
	case <-r.cancel:
		return
	default:
		close(r.cancel)
	}
}

func (c *consolidate) loop() {
	for {
		select {
		case <-c.cancel:
			return
		case <-c.ch:
			c.delayTimer.Reset(c.delay)
			if c.wdTimer == nil {
				c.wdTimer = time.After(c.maxDelay)
			}
		case <-c.delayTimer.C:
			c.doFunc()
			c.wdTimer = nil
		case <-c.wdTimer:
			c.doFunc()
			c.wdTimer = nil
		}
	}
}
